> We’ve implemented the first six of the 20 issues, can we do this stuff now or should do more of the 20

Short answer: **yes—you can start the mouselook/action‑combat work now** (and the telemetry scaffolding), **as long as the early scaffolding is in**. You don’t need the full server‑authoritative loop first; the controller is client‑local and can emit `InputCommand`s that the server later consumes. Below is a concrete go/no‑go checklist and what to take next.

---

## Go/No‑Go Checklist

**If these are done (or mostly done), green‑light 95E1 (mouselook) + 95T (telemetry):**

* ✅ 95A — Feature gates & quiet defaults (no client mutation by default)
* ✅ 95B — `client_core` (exists) and `net_core` (scaffolded)
* ✅ 95C — ECS components for destructibles/chunks (or at least a place to put `InputCommand`/controller state)
* ✅ 95D — Config loader is present (you can add `input_camera.toml`)

**If any are missing, do those first** to avoid rework (especially 95B & a spot to define `InputCommand`).

---

## What you can ship **now** (parallel‑friendly)

You can land these without waiting for the rest of the 20 issues. They won’t block or conflict with the server‑authoritative pivot as long as you follow the boundaries below.

### A) 95E1 — Action Combat & Mouselook (Neverwinter‑style default)

* **Lives in**: `client_core` (systems) + thin hooks in `render_wgpu` (draw reticle, apply camera pose).
* **Produces**: `InputCommand` events (`AtWillLMB`, `AtWillRMB`, `Encounter(Q/E/R)`, `Dodge`, `ClassMechanic`, `CursorToggle`, `LookDelta`).
* **Does NOT** mutate gameplay state; that remains server‑side when we do Phase 2.
* **Safe to merge early**: it’s UX/control only; later phases just start consuming its events.

**Guard rails**

* Put the state machine & pointer‑lock logic in `client_core::systems::{mouselook,cursor_toggle,camera,reticle,action_bindings}`.
* Renderer calls **only** into “read‑only” client_core facades: get camera pose & reticle state; draw them. No direct gameplay changes.
* Provide a `Classic Cursor` fallback profile (hold‑RMB to look) so you aren’t blocked by browser pointer‑lock quirks.

### B) 95T — Telemetry & Observability (scaffold)

* **Lives in**: a new `telemetry_core` or a tiny module in `net_core` + crate‑local init in client/server.
* **Produces**: metrics for input mode transitions, cast attempts vs authorized, reticle LoS blocked rate, chunk meshing budgets, frame/queue times.
* **Safe to merge early**: counters/timers are additive and can be no‑oped in dev.

**Guard rails**

* Use **Rust logging for human logs** (`tracing` or `log`) and **metrics for numbers**. Don’t mix them.
* Keep a single **init point** for telemetry sinks (env‑gated): dev → console; CI → no‑op; prod → Prometheus/OpenTelemetry (config‑driven).
* Make every event **dimension‑safe** (bounded labels) to avoid cardinality blowups.

---

## What to **defer** a bit (finish a few more issues first)

These benefit from having the foundational server loop ready (Phase 1/2), so keep them queued:

* Server‑side **VoxelCarveSystem/GreedyMeshSystem/ColliderRebuildSystem** (the carve/mesh/collider trio). If those three aren’t started (your “first six”), I’d do them **next** (they’re the keystone for switching the client off legacy carve for good).
* Minimal replication of **ChunkMeshDelta** (Phase 3 light). Even a local in‑proc channel is enough to start decoupling the renderer.

---

## Recommended next 2–3 PRs (assuming you’ve shipped the first six already)

1. **95E1‑P1 (Client)**

   * Implement **Mouselook + Cursor Toggle** (ALT toggle/hold), **reticle HUD**, **input profiles** (Action/Reticle default + Classic Cursor).
   * Emit `InputCommand`s; log counters via 95T; keep gameplay no‑op on server for now.

2. **95T‑P1 (Telemetry skeleton)**

   * Add `telemetry::init(config)` with a no‑op sink by default.
   * Counters (client): `controller.mode_transition`, `cursor_toggle{hold|toggle}`, `cast_input_total`.
   * Timers (renderer/client): `frame.input_ms`, `frame.upload_ms`.
   * Counters (server placeholder): `carve_request_total`, `mesh_jobs_enqueued_total`, `mesh_jobs_done_total`.

3. **Phase‑1 Server Trio (if not already in your “first six”)**

   * `VoxelCarveSystem` → marks `ChunkDirty`
   * `GreedyMeshSystem` (budgeted) → fills `ChunkMesh.map`
   * `ColliderRebuildSystem` (budgeted)
   * Add a **local replication** path to push `ChunkMeshDelta` to the client.
   * Flip renderer to upload meshes **only** from replication.

> If the server trio is already done, then pull 95E (controller/camera integration into renderer) to wire camera pose & reticle color (LoS/in‑range) using replicated hints.

---

## “Can we do this now?” decision matrix

| Work item                             | Needs server pieces? | Parallelizable now?   | Why                                                |
| ------------------------------------- | -------------------- | --------------------- | -------------------------------------------------- |
| 95E1 Mouselook/Action‑Combat (client) | No                   | **Yes**               | Emits commands; UX only; server will consume later |
| 95T Telemetry scaffold                | No                   | **Yes**               | Side‑effect free; plugs into later systems         |
| Server carve/mesh/collider trio       | Yes (server crate)   | **Yes** (separate PR) | Unblocks removing legacy client carve              |
| Minimal replication (ChunkMeshDelta)  | Light                | **Yes** (local loop)  | Lets renderer stop mutating world                  |
| Prediction/reconciliation             | Yes (net model)      | Not yet               | Comes after we have authoritative loop             |

---

## Practical coding notes (to reduce rework)

* Put `InputCommand` and `CameraPose` types in a **shared crate** (`ecs_core` or a tiny `game_messages` crate) so both client/server import the same enums/structs.
* Add a `client_core::ControllerFacade` with **read‑only getters**: `camera_pose()`, `reticle_state()`, `input_profile()`. Renderer reads this; it never modifies controller state directly.
* In `render_wgpu`, keep all new code behind `#[cfg(feature = "client_controller")]` for now; enable by default once stable.
* For telemetry, prefer `tracing` + `tracing-subscriber` and **opentelemetry/metrics** behind a feature flag (e.g., `telemetry`). Provide a `ConsoleSink` in dev and `PrometheusSink` in prod by config.

---

## Bottom line

* If your first six issues include the scaffolds/components/gates, **go ahead and implement the Neverwinter‑style mouselook controller (95E1) and telemetry scaffold (95T) now**. They’re client‑side and won’t block the server refactor.
* Next, **finish (or start) the server carve/mesh/collider trio + minimal replication** so we can permanently keep the renderer clean and flip the switch off the legacy carve path for good.

If you want, I can draft the exact PR checklists for **95E1‑P1** and **95T‑P1** with file paths and code skeletons you can hand directly to an agent.
