> Yes do it

Awesome—let’s lock in the two PRs you asked for. Below are **ready‑to‑paste GitHub issues** (with repo‑aware file paths, checklists, and code skeletons) for:

1. **95E1‑P1 — Action Combat & Mouselook (Neverwinter‑style default)**
2. **95T‑P1 — Telemetry Scaffold & Baseline Metrics**

They’re **supplemental** to your existing plan (they don’t replace any issue), parallel‑safe, and won’t fight the server‑authoritative refactor.

---

## ✅ Issue: 95E1‑P1 — Action Combat & Mouselook (Neverwinter‑style default)

**Labels:** client, input, camera, UX, mouselook
**Depends on:** 95A (gates), 95B (client_core scaffold)
**Blocks:** 95E1‑P2 (aim/reticle LoS coloring, accessibility), 95E2 (pad controls)

### Intent

Ship a Neverwinter‑style **action combat** control scheme as the **default**: continuous mouselook + reticle, left/right “At‑Will” bindings, dodge, encounters (Q/E/R), and a **toggle/hold cursor mode** for interacting with UI. Keep gameplay authoritative later by emitting **InputCommand** events only (no client‑side mutations).

### Outcomes

* `client_core` owns controller state & state machine (Action vs Cursor).
* `render_wgpu` only **queries** camera pose/reticle & draws; it does **not** mutate gameplay.
* Input is profile‑driven (Action/Classic), switchable at runtime.
* Emits `InputCommand` enums; server will consume them in Phase 2.

### Features / Flags

* `client_controller` (default **ON** for dev): compiles controller systems & façade.
* Optional config file: `data/config/input_camera.toml`.

### File layout & diffs

**New (client_core)**

```
crates/client_core/src/systems/mouselook.rs
crates/client_core/src/systems/cursor.rs
crates/client_core/src/systems/camera.rs
crates/client_core/src/systems/action_bindings.rs
crates/client_core/src/facade/controller.rs
```

**Touched**

```
crates/client_core/src/lib.rs
crates/client_core/Cargo.toml
crates/ecs_core/src/components.rs          (add shared types below)
crates/render_wgpu/src/gfx/renderer/input.rs   (route events)
crates/render_wgpu/src/gfx/renderer/update.rs  (apply camera pose only)
crates/render_wgpu/src/gfx/ui.rs               (draw reticle minimal)
crates/render_wgpu/Cargo.toml                  (feature flag)
data/config/input_camera.toml                  (new, optional)
```

### Shared types (add to `ecs_core/src/components.rs`)

```rust
/// Distinct control styles the player can select at runtime.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum InputProfile {
    /// Neverwinter-like action combat. Pointer locked by default; reticle active.
    ActionCombat,
    /// Classic MMO. Cursor visible; hold RMB to look.
    ClassicCursor,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ControllerMode {
    /// Pointer locked, reticle active, camera driven by mouse deltas.
    Mouselook,
    /// Cursor free; UI-interaction mode. No camera deltas unless RMB held (Classic).
    Cursor,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct CameraPose {
    pub eye: glam::Vec3,
    pub look_dir: glam::Vec3,
    pub up: glam::Vec3,
    // Optional: yaw/pitch cached to avoid gimbal lock on rebuilds.
    pub yaw: f32,
    pub pitch: f32,
}

/// Game-facing input commands (client → server in Phase 2).
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub enum InputCommand {
    AtWillLMB,         // primary
    AtWillRMB,         // secondary / block
    EncounterQ,
    EncounterE,
    EncounterR,
    Dodge,             // Shift
    ClassMechanic,     // e.g., Tab
    CursorToggle,      // Alt or configurable key
}
```

### Controller façade (read‑only getters)

`crates/client_core/src/facade/controller.rs`

```rust
#[derive(Default)]
pub struct ControllerState {
    pub profile: ecs_core::components::InputProfile,
    pub mode: ecs_core::components::ControllerMode,
    pub camera: ecs_core::components::CameraPose,
    pub reticle_world: glam::Vec3, // best-effort aim point; can be None later
    pub in_ui_capture: bool,
}

impl ControllerState {
    pub fn camera_pose(&self) -> ecs_core::components::CameraPose { self.camera }
    pub fn reticle_world(&self) -> glam::Vec3 { self.reticle_world }
    pub fn mode(&self) -> ecs_core::components::ControllerMode { self.mode }
    pub fn profile(&self) -> ecs_core::components::InputProfile { self.profile }
}

/// Buffer of InputCommands generated this frame. Client will flush to server later.
pub struct InputQueue {
    cmds: smallvec::SmallVec<[ecs_core::components::InputCommand; 8]>,
}
impl InputQueue {
    pub fn push(&mut self, c: ecs_core::components::InputCommand) { self.cmds.push(c); }
    pub fn drain(&mut self) -> impl Iterator<Item = ecs_core::components::InputCommand> + '_ {
        self.cmds.drain(..)
    }
}
```

### Systems: mouselook/cursor/camera/action_bindings

`crates/client_core/src/systems/mouselook.rs`

```rust
pub struct MouselookConfig {
    pub sensitivity_deg_per_count: f32,
    pub invert_y: bool,
    pub min_pitch_deg: f32,
    pub max_pitch_deg: f32,
}

pub fn apply_mouse_delta(
    cfg: &MouselookConfig,
    state: &mut crate::facade::controller::ControllerState,
    dx: f32,
    dy: f32,
) {
    use ecs_core::components::ControllerMode;
    if state.mode != ControllerMode::Mouselook { return; }
    let mut yaw = state.camera.yaw + dx * cfg.sensitivity_deg_per_count.to_radians();
    let mut pitch = state.camera.pitch
        + (if cfg.invert_y { dy } else { -dy }) * cfg.sensitivity_deg_per_count.to_radians();
    pitch = pitch.clamp(cfg.min_pitch_deg.to_radians(), cfg.max_pitch_deg.to_radians());

    // Recompute look dir
    let cp = glam::Vec3::new(pitch.cos() * yaw.cos(), pitch.sin(), pitch.cos() * yaw.sin());
    state.camera.yaw = yaw;
    state.camera.pitch = pitch;
    state.camera.look_dir = cp.normalize();
}
```

`crates/client_core/src/systems/cursor.rs`

```rust
use ecs_core::components::{ControllerMode, InputProfile};

pub struct CursorConfig {
    pub toggle_key: winit::keyboard::KeyCode, // e.g., AltLeft
    pub classic_hold_mouse_right: bool,
}

pub enum CursorEvent {
    TogglePressed,
    MouseRight(bool), // down/up
}

pub fn handle_cursor_event(
    cfg: &CursorConfig,
    state: &mut crate::facade::controller::ControllerState,
    ev: CursorEvent,
) {
    match ev {
        CursorEvent::TogglePressed => {
            // Toggle between Cursor <-> Mouselook
            state.mode = match state.mode {
                ControllerMode::Mouselook => ControllerMode::Cursor,
                ControllerMode::Cursor => ControllerMode::Mouselook,
            };
        }
        CursorEvent::MouseRight(down) if state.profile == InputProfile::ClassicCursor => {
            state.mode = if down { ControllerMode::Mouselook } else { ControllerMode::Cursor };
        }
        _ => {}
    }
}
```

`crates/client_core/src/systems/camera.rs`

```rust
pub struct CameraFollowConfig {
    pub shoulder_offset: glam::Vec3, // e.g., (0.0, 1.6, 0.0)
    pub distance: f32,               // 3rd-person boom
    pub smoothing: f32,              // 0..1 lerp
}

pub fn update_third_person_camera(
    cfg: &CameraFollowConfig,
    state: &mut crate::facade::controller::ControllerState,
    player_transform: glam::Mat4,
) {
    let eye_target = player_transform.transform_point3(cfg.shoulder_offset);
    let eye = eye_target - state.camera.look_dir * cfg.distance;
    let smooth = cfg.smoothing.clamp(0.0, 1.0);
    state.camera.eye = state.camera.eye.lerp(eye, smooth);
}
```

`crates/client_core/src/systems/action_bindings.rs`

```rust
use ecs_core::components::InputCommand as IC;

pub struct Bindings {
    pub lmb: IC, // AtWillLMB
    pub rmb: IC, // AtWillRMB (or Block)
    pub q: IC,   // EncounterQ
    pub e: IC,
    pub r: IC,
    pub shift: IC, // Dodge
    pub tab: IC,   // ClassMechanic
}

pub fn handle_buttons(
    binds: &Bindings,
    state: &crate::facade::controller::ControllerState,
    input: &crate::input::ButtonSnapshot, // provide a small per-frame input snapshot
    out: &mut crate::facade::controller::InputQueue,
) {
    use ecs_core::components::ControllerMode::*;
    // Only emit combat commands when in Mouselook (Action profile).
    if state.mode == Mouselook {
        if input.lmb_pressed  { out.push(binds.lmb.clone()); }
        if input.rmb_pressed  { out.push(binds.rmb.clone()); }
        if input.q_pressed    { out.push(binds.q.clone()); }
        if input.e_pressed    { out.push(binds.e.clone()); }
        if input.r_pressed    { out.push(binds.r.clone()); }
        if input.shift_pressed{ out.push(binds.shift.clone()); }
        if input.tab_pressed  { out.push(binds.tab.clone()); }
    }
}
```

### Renderer integration (thin hooks, **no gameplay mutations**)

`crates/render_wgpu/src/gfx/renderer/input.rs` (pseudocode snippets)

```rust
// On winit device events (raw mouse)
if let winit::event::DeviceEvent::MouseMotion { delta: (dx, dy) } = event {
    client_core::systems::mouselook::apply_mouse_delta(
        &self.controller_cfg.mouselook, &mut self.controller_state, dx as f32, dy as f32
    );
}

// On window events (cursor toggle / hold RMB)
if let winit::event::WindowEvent::KeyboardInput { event, .. } = event {
    if is_toggle_key(event) && event.state.is_pressed() {
        client_core::systems::cursor::handle_cursor_event(
            &self.controller_cfg.cursor, &mut self.controller_state,
            client_core::systems::cursor::CursorEvent::TogglePressed);
        // Also set/clear OS cursor grab/visibility:
        self.platform.set_cursor_captured(self.controller_state.mode == Mouselook);
    }
}
if let winit::event::WindowEvent::MouseInput { state, button, .. } = event {
    if button == winit::event::MouseButton::Right {
        client_core::systems::cursor::handle_cursor_event(
            &self.controller_cfg.cursor, &mut self.controller_state,
            client_core::systems::cursor::CursorEvent::MouseRight(state.is_pressed()));
        self.platform.set_cursor_captured(self.controller_state.mode == Mouselook);
    }
}
```

`crates/render_wgpu/src/gfx/renderer/update.rs` (apply camera pose)

```rust
// Per-frame: read-only controller pose and apply to view matrix
let cp = self.controller_state.camera_pose();
self.camera.set_eye_dir(cp.eye, cp.look_dir, cp.up);

// Draw reticle:
if self.controller_state.mode() == ecs_core::components::ControllerMode::Mouselook {
    self.ui.draw_reticle(/* color from LoS check later */);
}
```

### Config (optional)

`data/config/input_camera.toml`

```toml
[controller]
default_profile = "ActionCombat"

[mouselook]
sensitivity_deg_per_count = 0.1
invert_y = false
min_pitch_deg = -80
max_pitch_deg = 80

[camera]
shoulder_offset = [0.0, 1.6, 0.0]
distance = 3.0
smoothing = 0.2

[cursor]
toggle_key = "AltLeft"
classic_hold_mouse_right = true
```

### Tests

* **Unit (client_core):**

  * yaw/pitch clamp invariant; invert_y works.
  * Cursor toggle flips `ControllerMode`; ClassicCursor hold‑RMB transitions in/out.
* **Smoke (renderer, headless):** controller pose produces a non‑degenerate view dir; reticle draws only in Mouselook.

### Acceptance

* Default profile = **ActionCombat** with continuous mouselook/reticle; toggle key releases cursor.
* Commands (`InputCommand`) are produced but **no gameplay state is mutated**.
* Classic profile can be enabled and behaves as expected (hold RMB to look).
* Works on native (winit) and keeps gates for WASM later.

---

## ✅ Issue: 95T‑P1 — Telemetry Scaffold & Baseline Metrics

**Labels:** telemetry, observability, infra
**Depends on:** none (can ship anytime)
**Blocks:** later performance tuning & server budgets

### Intent

Introduce **production‑grade telemetry** that cleanly separates **logs** from **metrics**, supports **dev/CI/prod** sinks, and is trivial to expand. All counters/timers must be **dimension‑safe** (bounded labels), opt‑in by feature or config, and initialized from a single entrypoint.

### Approach

* **Logs:** `tracing` + `tracing-subscriber` with `EnvFilter`.
* **Metrics:** `metrics` crate with pluggable exporters:

  * Dev: `metrics-exporter-prometheus` (scrape on localhost)
  * CI: no‑op
  * Prod (later): OpenTelemetry metrics (OTLP)
* Single init function `telemetry_core::init(config)` to wire sinks.

### Features / Flags

* `telemetry` (default **ON** in dev), disables in CI if desired via env.

### File layout

**New crate**

```
crates/telemetry_core/Cargo.toml
crates/telemetry_core/src/lib.rs
crates/telemetry_core/src/config.rs
```

**Touched**

```
crates/client_core/src/lib.rs          (telemetry::init in client main path)
crates/server_core/src/lib.rs          (telemetry::init in server path)
crates/render_wgpu/src/main.rs         (if a bin; otherwise platform_winit launcher)
xtask/ or .github/workflows/ci.yml     (optional matrix)
```

### Code skeleton

`crates/telemetry_core/src/config.rs`

```rust
#[derive(Clone, Debug)]
pub struct TelemetryConfig {
    pub enable_tracing: bool,
    pub tracing_filter: String, // e.g., "info,render_wgpu=warn"
    pub enable_metrics: bool,
    pub exporter: MetricsExporter, // Noop | Prometheus { addr } | Otel { endpoint }
}

#[derive(Clone, Debug)]
pub enum MetricsExporter {
    Noop,
    Prometheus { bind_addr: std::net::SocketAddr },
    #[cfg(feature = "otel")]
    Otel { endpoint: String },
}

impl Default for TelemetryConfig {
    fn default() -> Self {
        Self {
            enable_tracing: true,
            tracing_filter: "info".to_string(),
            enable_metrics: true,
            exporter: MetricsExporter::Noop,
        }
    }
}
```

`crates/telemetry_core/src/lib.rs`

```rust
pub mod config;
use config::{TelemetryConfig, MetricsExporter};

pub fn init(cfg: &TelemetryConfig) -> anyhow::Result<()> {
    if cfg.enable_tracing {
        let filter = cfg.tracing_filter.parse::<tracing_subscriber::EnvFilter>()
            .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"));
        tracing_subscriber::fmt()
            .with_env_filter(filter)
            .with_ansi(atty::is(atty::Stream::Stdout))
            .init();
    }

    if cfg.enable_metrics {
        match &cfg.exporter {
            MetricsExporter::Noop => { /* nothing */ }
            MetricsExporter::Prometheus { bind_addr } => {
                let builder = metrics_exporter_prometheus::PrometheusBuilder::new();
                let handle = builder
                    .with_http_listener(*bind_addr)
                    .install_recorder()?;
                // Keep handle alive somewhere if we need direct scrape endpoint metadata
                let _ = handle;
            }
            #[cfg(feature = "otel")]
            MetricsExporter::Otel { endpoint } => {
                // Wire OpenTelemetry metrics exporter (later)
            }
        }
    }
    Ok(())
}

// Convenience macros (optional), or use `metrics::*` macros directly
#[macro_export]
macro_rules! inc {
    ($name:literal $(, $val:expr)? $(, $k:literal => $v:expr)*) => {{
        metrics::increment_counter!($name $(, $val)? $(, $k => $v)*);
    }};
}
#[macro_export]
macro_rules! hist {
    ($name:literal, $val:expr $(, $k:literal => $v:expr)*) => {{
        metrics::histogram!($name, $val $(, $k => $v)* );
    }};
}
```

**Client hooks (minimal, safe now)**

`crates/client_core/src/facade/controller.rs` (instrument transitions)

```rust
pub fn set_mode(&mut self, new_mode: ecs_core::components::ControllerMode) {
    if self.mode != new_mode {
        self.mode = new_mode;
        telemetry_core::inc!("controller.mode_transition_total",
            1, "mode" => format!("{:?}", self.mode));
    }
}
```

`crates/client_core/src/systems/mouselook.rs` (measure sensitivity impact)

```rust
pub fn apply_mouse_delta(/* ... */) {
    let t0 = std::time::Instant::now();
    // existing work ...
    telemetry_core::hist!("client.input.mouselook.apply_ms",
        t0.elapsed().as_secs_f64() * 1000.0);
}
```

**Renderer frame timings (non‑gameplay)**

```rust
let t_frame = std::time::Instant::now();
// input + controller read
telemetry_core::hist!("client.frame.input_ms", t_input.as_secs_f64() * 1000.0);
// upload meshes timing if present
telemetry_core::hist!("client.frame.upload_ms", t_upload.as_secs_f64() * 1000.0);
// end frame
telemetry_core::hist!("client.frame.total_ms", t_frame.elapsed().as_secs_f64() * 1000.0);
```

**Server carve/mesh (future‑proof stubs now)**

```rust
// When these systems land, emit:
telemetry_core::inc!("server.voxel.mesh_jobs_enqueued_total", 1);
telemetry_core::inc!("server.voxel.mesh_jobs_done_total", n_done);
telemetry_core::hist!("server.voxel.mesh_job_ms", dt_ms, "kind" => "greedy");
```

### Config examples (dev vs CI)

* **Dev (local Prometheus on :9090)**

```rust
let cfg = telemetry_core::config::TelemetryConfig {
    enable_tracing: true,
    tracing_filter: "info,render_wgpu=warn,client_core=info".into(),
    enable_metrics: true,
    exporter: telemetry_core::config::MetricsExporter::Prometheus {
        bind_addr: "127.0.0.1:9888".parse().unwrap(),
    },
};
telemetry_core::init(&cfg)?;
```

* **CI**

```rust
telemetry_core::init(&TelemetryConfig { enable_tracing: true, enable_metrics: false, ..Default::default() })?;
```

### Tests

* **Unit (telemetry_core):**

  * `init()` with Noop exporter succeeds.
  * Prometheus exporter binds to random port (use `127.0.0.1:0`) without panic.
* **Smoke (client_core):**

  * Calling `set_mode` increments counter exactly once per transition.
  * `apply_mouse_delta` records histogram (can mock time or just assert code path).

### Acceptance

* One‑line `telemetry_core::init()` brings up logs + metrics in dev; CI uses no‑op.
* No panics if exporter unavailable; clean startup/shutdown.
* Controller transitions/camera and per‑frame timings produce metrics.
* No high‑cardinality labels (only bounded enums like mode/profile/kind).

---

## Why this ordering is safe

* **95E1‑P1** is purely **client‑side UX**; it only emits `InputCommand` and exposes a read‑only camera pose/reticle. It won’t collide with the server ECS refactor.
* **95T‑P1** adds passive counters/timings and can be extended everywhere later; it doesn’t change gameplay flow.

---

## Optional follow‑ups you can queue now

* **95E1‑P2:** Reticle LoS coloring, “in‑range” rings, accessibility (invert X, sticky targeting, larger reticle).
* **95T‑P2:** Add server budgets (mesh/collider) & per‑system tick histograms; expose `/metrics` HTTP endpoint only in dev builds.

---

If you want, I can also draft the **exact commits checklist** (command‑by‑command, with `apply_patch` style diffs) an agent can follow, but the above is enough to implement without guesswork.
